// generated by smg -output misc/fixture/e/model_search.go misc/fixture/e; DO NOT EDIT

package e

import (
	"bytes"
	"encoding/json"
	"errors"
	"github.com/favclip/smg/smgutils"
	"golang.org/x/net/context"
	"google.golang.org/appengine/log"
	"google.golang.org/appengine/search"
	"strconv"
	"time"
)

// for Inventory
type InventorySearch struct {
	src *Inventory

	ID                 string
	ProductName        string
	Description        string
	DescriptionUnigram string
	DescriptionBigram  string
	Stock              float64
	Price              string
	Barcode            string
	AdminNames         string
	Shops              string
	CreatedAt          time.Time
}

func (s *InventorySearch) Load(fields []search.Field, metadata *search.DocumentMetadata) error {
	return search.LoadStruct(s, fields)
}

func (s *InventorySearch) Save() ([]search.Field, *search.DocumentMetadata, error) {
	fields, err := search.SaveStruct(s)
	if err != nil {
		return nil, nil, err
	}
	// https://cloud.google.com/appengine/docs/go/search/reference#DocumentMetadata
	// 0 origin value can not be correctly sorted.
	// Typically, the data is assumed to be 0's origin, 1 added every time.
	metadata := &search.DocumentMetadata{Rank: int(s.Stock) + 1}

	return fields, metadata, nil
}

func (src *Inventory) Searchfy() (*InventorySearch, error) {
	if src == nil {
		return nil, nil
	}
	dest := &InventorySearch{}
	dest.src = src
	var err error
	var b []byte
	dest.ID = strconv.FormatInt(src.ID, 10)
	dest.ProductName = src.ProductName

	dest.Description = src.Description
	dest.DescriptionUnigram, err = smgutils.UnigramForSearch(src.Description)
	if err != nil {
		return nil, err
	}
	dest.DescriptionBigram, err = smgutils.BigramForSearch(src.Description)
	if err != nil {
		return nil, err
	}
	dest.Stock = float64(src.Stock)
	dest.Price = strconv.Itoa(src.Price)
	dest.Barcode = strconv.FormatInt(src.Barcode, 10)

	b, err = json.Marshal(src.AdminNames)
	if err != nil {
		return nil, err
	}
	if str := string(b); str != "" && str != "\"\"" {
		dest.AdminNames = str
	}

	b, err = json.Marshal(src.Shops)
	if err != nil {
		return nil, err
	}
	if str := string(b); str != "" && str != "\"\"" {
		dest.Shops = str
	}
	dest.CreatedAt = src.CreatedAt
	return dest, nil
}

func NewInventorySearch() *InventorySearchBuilder {
	op := &smgutils.Op{}
	b := &InventorySearchBuilder{
		rootOp:    op,
		currentOp: op,
	}
	b.ProductName = &InventorySearchStringPropertyInfo{"ProductName", b}
	b.Description = &InventorySearchNgramStringPropertyInfo{InventorySearchStringPropertyInfo{"Description", b}}
	b.Stock = &InventorySearchNumberPropertyInfo{"Stock", b}
	b.Price = &InventorySearchStringPropertyInfo{"Price", b}
	b.Barcode = &InventorySearchStringPropertyInfo{"Barcode", b}
	b.AdminNames = &InventorySearchStringPropertyInfo{"AdminNames", b}
	b.Shops = &InventorySearchStringPropertyInfo{"Shops", b}
	b.CreatedAt = &InventorySearchTimePropertyInfo{"CreatedAt", b}

	return b
}

type InventorySearchBuilder struct {
	rootOp      *smgutils.Op
	currentOp   *smgutils.Op // for grouping
	opts        *search.SearchOptions
	query       string
	index       *search.Index
	ProductName *InventorySearchStringPropertyInfo
	Description *InventorySearchNgramStringPropertyInfo
	Stock       *InventorySearchNumberPropertyInfo
	Price       *InventorySearchStringPropertyInfo
	Barcode     *InventorySearchStringPropertyInfo
	AdminNames  *InventorySearchStringPropertyInfo
	Shops       *InventorySearchStringPropertyInfo
	CreatedAt   *InventorySearchTimePropertyInfo
}

func (b *InventorySearchBuilder) And() *InventorySearchBuilder {
	b.currentOp.Children = append(b.currentOp.Children, &smgutils.Op{Type: smgutils.And})
	return b
}

func (b *InventorySearchBuilder) Or() *InventorySearchBuilder {
	b.currentOp.Children = append(b.currentOp.Children, &smgutils.Op{Type: smgutils.Or})
	return b
}

func (b *InventorySearchBuilder) Group(p func()) *InventorySearchBuilder {
	b.StartGroup()
	p()
	b.EndGroup()
	return b
}

func (b *InventorySearchBuilder) StartGroup() *InventorySearchBuilder {
	op := &smgutils.Op{Type: smgutils.Group, Parent: b.currentOp}
	b.currentOp.Children = append(b.currentOp.Children, op)
	b.currentOp = op
	return b
}

func (b *InventorySearchBuilder) EndGroup() *InventorySearchBuilder {
	b.currentOp = b.currentOp.Parent
	return b
}

func (b *InventorySearchBuilder) Put(c context.Context, src *Inventory) (string, error) {
	doc, err := src.Searchfy()
	if err != nil {
		return "", err
	}
	return b.PutDocument(c, doc)
}

func (b *InventorySearchBuilder) PutDocument(c context.Context, src *InventorySearch) (string, error) {
	index, err := search.Open("Inventory")
	if err != nil {
		return "", err
	}

	docID := ""
	if v, ok := interface{}(src).(smgutils.DocIDer); ok { // TODO can I shorten this cond expression?
		docID, err = v.DocID(c)
		if err != nil {
			return "", err
		}
		src.ID = docID
	}

	log.Debugf(c, "id: %#v, payload: %#v", docID, src)

	docID, err = index.Put(c, docID, src)
	if err != nil {
		return "", err
	}

	src.ID = docID

	return docID, nil
}

func (b *InventorySearchBuilder) Delete(c context.Context, src *Inventory) error {
	doc, err := src.Searchfy()
	if err != nil {
		return err
	}
	return b.DeleteDocument(c, doc)
}

func (b *InventorySearchBuilder) DeleteDocument(c context.Context, src *InventorySearch) error {
	if v, ok := interface{}(src).(smgutils.DocIDer); ok { // TODO can I shorten this cond expression?
		docID, err := v.DocID(c)
		if err != nil {
			return err
		}
		return b.DeleteByDocID(c, docID)
	}

	return errors.New("src is not implemented DocIDer interface")
}

func (b *InventorySearchBuilder) DeleteByDocID(c context.Context, docID string) error {
	index, err := search.Open("Inventory")
	if err != nil {
		return err
	}

	return index.Delete(c, docID)
}

func (b *InventorySearchBuilder) Opts() *InventorySearchOptions {
	return &InventorySearchOptions{b: b}
}

func (b *InventorySearchBuilder) Search(c context.Context) (*InventorySearchIterator, error) {
	index, err := search.Open("Inventory")
	if err != nil {
		return nil, err
	}
	b.index = index

	buffer := &bytes.Buffer{}
	err = b.rootOp.Query(buffer)
	if err != nil {
		return nil, err
	}
	b.query = buffer.String()
	log.Debugf(c, "query: '%s', opts: %#v", b.query, b.opts)
	iter := b.index.Search(c, b.query, b.opts)

	return &InventorySearchIterator{b, iter}, nil
}

type InventorySearchOptions struct {
	b *InventorySearchBuilder
}

func (b *InventorySearchOptions) Limit(value int) *InventorySearchOptions {
	if b.b.opts == nil {
		b.b.opts = &search.SearchOptions{}
	}
	b.b.opts.Limit = value
	return b
}

func (b *InventorySearchOptions) IDsOnly() *InventorySearchOptions {
	if b.b.opts == nil {
		b.b.opts = &search.SearchOptions{}
	}
	b.b.opts.IDsOnly = true
	return b
}

type InventorySearchIterator struct {
	b    *InventorySearchBuilder
	iter *search.Iterator
}

func (b *InventorySearchIterator) Next(c context.Context) (string, *InventorySearch, error) {
	var s *InventorySearch
	if b.b.opts == nil || b.b.opts.IDsOnly != true {
		s = &InventorySearch{}
	}

	docID, err := b.iter.Next(s)
	if err != nil {
		return "", nil, err
	}
	if s != nil {
		s.ID = docID
	}

	return docID, s, err
}

type InventorySearchStringPropertyInfo struct {
	Name string
	b    *InventorySearchBuilder
}

func (p *InventorySearchStringPropertyInfo) Match(value string) *InventorySearchBuilder {
	p.b.currentOp.Children = append(p.b.currentOp.Children, &smgutils.Op{FieldName: p.Name, Type: smgutils.Match, Value: value})
	return p.b
}

func (p *InventorySearchStringPropertyInfo) Asc() *InventorySearchBuilder {
	if p.b.opts == nil {
		p.b.opts = &search.SearchOptions{}
	}
	if p.b.opts.Sort == nil {
		p.b.opts.Sort = &search.SortOptions{}
	}
	p.b.opts.Sort.Expressions = append(p.b.opts.Sort.Expressions, search.SortExpression{
		Expr:    p.Name,
		Reverse: true,
	})

	return p.b
}

func (p *InventorySearchStringPropertyInfo) Desc() *InventorySearchBuilder {
	if p.b.opts == nil {
		p.b.opts = &search.SearchOptions{}
	}
	if p.b.opts.Sort == nil {
		p.b.opts.Sort = &search.SortOptions{}
	}
	p.b.opts.Sort.Expressions = append(p.b.opts.Sort.Expressions, search.SortExpression{
		Expr:    p.Name,
		Reverse: false,
	})

	return p.b
}

type InventorySearchNgramStringPropertyInfo struct {
	InventorySearchStringPropertyInfo
}

func (p *InventorySearchNgramStringPropertyInfo) NgramMatch(value string) *InventorySearchBuilder {
	p.b.currentOp.Children = append(p.b.currentOp.Children, &smgutils.Op{FieldName: p.Name, Type: smgutils.NgramMatch, Value: value})
	return p.b
}

type InventorySearchNumberPropertyInfo struct {
	Name string
	b    *InventorySearchBuilder
}

func (p *InventorySearchNumberPropertyInfo) IntGreaterThanOrEqual(value int) *InventorySearchBuilder {
	p.b.currentOp.Children = append(p.b.currentOp.Children, &smgutils.Op{FieldName: p.Name, Type: smgutils.GtEq, Value: value})
	return p.b
}

func (p *InventorySearchNumberPropertyInfo) IntGreaterThan(value int) *InventorySearchBuilder {
	p.b.currentOp.Children = append(p.b.currentOp.Children, &smgutils.Op{FieldName: p.Name, Type: smgutils.Gt, Value: value})
	return p.b
}

func (p *InventorySearchNumberPropertyInfo) IntLessThanOrEqual(value int) *InventorySearchBuilder {
	p.b.currentOp.Children = append(p.b.currentOp.Children, &smgutils.Op{FieldName: p.Name, Type: smgutils.LtEq, Value: value})
	return p.b
}

func (p *InventorySearchNumberPropertyInfo) IntLessThan(value int) *InventorySearchBuilder {
	p.b.currentOp.Children = append(p.b.currentOp.Children, &smgutils.Op{FieldName: p.Name, Type: smgutils.Lt, Value: value})
	return p.b
}

func (p *InventorySearchNumberPropertyInfo) IntEqual(value int) *InventorySearchBuilder {
	p.b.currentOp.Children = append(p.b.currentOp.Children, &smgutils.Op{FieldName: p.Name, Type: smgutils.Eq, Value: value})
	return p.b
}

func (p *InventorySearchNumberPropertyInfo) Int64GreaterThanOrEqual(value int64) *InventorySearchBuilder {
	p.b.currentOp.Children = append(p.b.currentOp.Children, &smgutils.Op{FieldName: p.Name, Type: smgutils.GtEq, Value: value})
	return p.b
}

func (p *InventorySearchNumberPropertyInfo) Int64GreaterThan(value int64) *InventorySearchBuilder {
	p.b.currentOp.Children = append(p.b.currentOp.Children, &smgutils.Op{FieldName: p.Name, Type: smgutils.Gt, Value: value})
	return p.b
}

func (p *InventorySearchNumberPropertyInfo) Int64LessThanOrEqual(value int64) *InventorySearchBuilder {
	p.b.currentOp.Children = append(p.b.currentOp.Children, &smgutils.Op{FieldName: p.Name, Type: smgutils.LtEq, Value: value})
	return p.b
}

func (p *InventorySearchNumberPropertyInfo) Int64LessThan(value int64) *InventorySearchBuilder {
	p.b.currentOp.Children = append(p.b.currentOp.Children, &smgutils.Op{FieldName: p.Name, Type: smgutils.Lt, Value: value})
	return p.b
}

func (p *InventorySearchNumberPropertyInfo) Int64Equal(value int64) *InventorySearchBuilder {
	p.b.currentOp.Children = append(p.b.currentOp.Children, &smgutils.Op{FieldName: p.Name, Type: smgutils.Eq, Value: value})
	return p.b
}

func (p *InventorySearchNumberPropertyInfo) Asc() *InventorySearchBuilder {
	if p.b.opts == nil {
		p.b.opts = &search.SearchOptions{}
	}
	if p.b.opts.Sort == nil {
		p.b.opts.Sort = &search.SortOptions{}
	}
	p.b.opts.Sort.Expressions = append(p.b.opts.Sort.Expressions, search.SortExpression{
		Expr:    p.Name,
		Reverse: true,
	})

	return p.b
}

func (p *InventorySearchNumberPropertyInfo) Desc() *InventorySearchBuilder {
	if p.b.opts == nil {
		p.b.opts = &search.SearchOptions{}
	}
	if p.b.opts.Sort == nil {
		p.b.opts.Sort = &search.SortOptions{}
	}
	p.b.opts.Sort.Expressions = append(p.b.opts.Sort.Expressions, search.SortExpression{
		Expr:    p.Name,
		Reverse: false,
	})

	return p.b
}

type InventorySearchBoolPropertyInfo struct {
	Name string
	b    *InventorySearchBuilder
}

func (p *InventorySearchNumberPropertyInfo) Equal(value bool) *InventorySearchBuilder {
	p.b.currentOp.Children = append(p.b.currentOp.Children, &smgutils.Op{FieldName: p.Name, Type: smgutils.Eq, Value: value})
	return p.b
}

type InventorySearchTimePropertyInfo struct {
	Name string
	b    *InventorySearchBuilder
}

func (p *InventorySearchTimePropertyInfo) Asc() *InventorySearchBuilder {
	if p.b.opts == nil {
		p.b.opts = &search.SearchOptions{}
	}
	if p.b.opts.Sort == nil {
		p.b.opts.Sort = &search.SortOptions{}
	}
	p.b.opts.Sort.Expressions = append(p.b.opts.Sort.Expressions, search.SortExpression{
		Expr:    p.Name,
		Reverse: true,
	})

	return p.b
}

func (p *InventorySearchTimePropertyInfo) Desc() *InventorySearchBuilder {
	if p.b.opts == nil {
		p.b.opts = &search.SearchOptions{}
	}
	if p.b.opts.Sort == nil {
		p.b.opts.Sort = &search.SortOptions{}
	}
	p.b.opts.Sort.Expressions = append(p.b.opts.Sort.Expressions, search.SortExpression{
		Expr:    p.Name,
		Reverse: false,
	})

	return p.b
}
